強固なデータ・インフラストラクチャを構築するためのログの活用（デュアル書き込みがダメな理由）
===========================================================================================

[Part1](http://postd.cc/using-logs-to-build-a-solid-data-infrastructure-part-1/)

- 確実にデータをディスクに保存 => ログ
- どのようにして他のレプリカと同期  => ログ
- 合意 => ログ
- 追加専用の、完全に順序立った一連のレコード
- memcached、Redis、Elaticsearch、Hadoop、グラフDB...
- 問題はストレージシステムの多くが同じまたは関連するデータを持っていながら、形式が異なっている
- データ統合: 適切に格納されるようにする
- 異なるデータシステムの同期 => デュアル書き込み
  - Webアプリで異なるストレージの更新管理
- デュアル書き込みは仕組み上データ不整合を起こす => トランザクション
- 異なるストレージに対してトランザクションをはるには？
- 分散トランザクション
  - 2相コミット
  - データストアがサポートしていない
- 単純な解決策: 決まった順序でデータの書き込みをし、決まった順序で格納
- ユーザがデータを書き込む際は、その書き込みをレコードの並びの最後に追加 => 追記書き込み
- これをログというデータ構造

[Part2](http://postd.cc/using-logs-to-build-a-solid-data-infrastructure-part-2/)

- 1. DBストレージエンジン
  - B-tree ストレージエンジンに広く使われているデータ構造
  - ページを分ける際、最低でも3ページをディスクに書き込む必要がある
    - 分けた結果の2ページと、その親のページ
    - 処理の途中、全てのページがディスクに書き込まれる前にデータベースがクラッシュしたら?
  - B-treeの信頼性を担保するために、ログ先行書き込み（WAL）を使う
  - ログを一次的なストレージ媒体として使える？
    - ログ構造化方式 (LSM tree)
    - HBase Cassandra Riak
  - ログはセグメントに分割され、時々ストレージエンジンがセグメントをマージし、重複したキーを廃棄
- 2. DBレプリケーション
  - 一般的なのは1つのノードをリーダーとし、他のレプリカをフォロワーとする。マスタ/スレーブ
  - クライアントが書き込むときはリーダーに通知
  - リードオンリーのクライアントはリーダーまたはフォロワーを参照
  - リーダーに何らかのデータが書き込まれると、レプリケーションログに追加
  - フォロワーは書き込まれた順にログを読み出し、自分が持っているデータコピーに、それぞれの書き込みを追加
  - "書き込みの流れから全ての非決定性を追い出す"
  - フォロワーがトランザクションからの最初の書き込みの処理に成功した後、トランザクションからの2番目の書き込みに失敗してしまう
- 3. 分散合意
  - 
- 4. Kafka

